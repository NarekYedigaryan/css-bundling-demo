CSS Source Map Investigation Report
Selected Element: The Button (.btn)
I chose the button element because it has complex styling involving:

Multiple CSS properties

SCSS variables

Pseudo-classes (:hover)

Nested selectors (in source)

Generated vendor prefixes

Investigation of 5 CSS Properties:
1. background-color
Computed Value: rgb(52, 152, 219)
Rules in Styles Panel:

text
.btn {
  background-color: #3498db;
}
.btn:hover {
  background-color: #2980b9;
}
Generated CSS Location: index.css:45:2
Original Source: src/styles/components/_buttons.scss:2:14
Source Map Trace: ✅ Perfect mapping to _buttons.scss line 2

2. padding
Computed Value: 12px 24px
Rules in Styles Panel:

text
.btn {
  padding: 12px 24px;
}
Generated CSS Location: index.css:47:2
Original Source: src/styles/components/_buttons.scss:4:14
Source Map Trace: ✅ Direct mapping, but note: original uses 0.75rem 1.5rem which compiled to 12px 24px

3. transition
Computed Value: background-color 0.2s ease 0s
Rules in Styles Panel:

text
.btn {
  transition: background-color 0.2s;
}
Generated CSS Location: index.css:50:2
Original Source: src/styles/components/_buttons.scss:7:14
Source Map Trace: ✅ Direct mapping

4. border-radius
Computed Value: 4px
Rules in Styles Panel:

text
.btn {
  border-radius: 4px;
}
Generated CSS Location: index.css:48:2
Original Source: src/styles/components/_buttons.scss:5:17
Source Map Trace: ✅ Direct mapping

5. display
Computed Value: inline-block
Rules in Styles Panel:

text
.btn {
  display: inline-block;
}
Generated CSS Location: index.css:44:2
Original Source: src/styles/components/_buttons.scss:1:14
Source Map Trace: ✅ Direct mapping

Three Cases Where Mapping Becomes Ambiguous/Problematic:
Case 1: SCSS Variable Substitution
Issue: The button's background-color shows as #3498db in computed styles, but in the original SCSS it's $primary.
Why ambiguous: DevTools shows the computed hex value, not the variable name. To trace back:

See background-color: #3498db in Styles panel

Click to go to generated CSS

Source map points to line with $primary

Must manually check _variables.scss to find $primary: #3498db
Breakdown: No direct link from computed value to variable definition.

Case 2: :hover Pseudo-class on Hover State
Issue: When hovering over the button, background-color changes to #2980b9.
Why ambiguous:

Hover state is dynamic - not visible in Elements panel until hovering

Generated CSS shows both normal and hover states

Source map points to same .btn block in SCSS

Hard to distinguish which part of nested SCSS generated which CSS rule
Example SCSS source:

scss
.btn {
  background-color: $primary;
  
  &:hover {
    background-color: darken($primary, 10%);
  }
}
Generated as two separate rules in CSS.

Case 3: CSS Generated by PostCSS (Autoprefixer)
Issue: Some properties like user-select or transition might get vendor prefixes.
Why ambiguous:

Generated CSS contains -webkit-user-select, -moz-user-select, etc.

Original SCSS only has user-select: none;

Source maps point to original line but don't explain the transformation

No indication that PostCSS/autoprefixer generated extra rules
Example: If we had user-select: none; in SCSS, generated CSS would show:

text
-webkit-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
All map to same source line, but only one was authored.

Source Map Limitations Observed:
No variable tracing: Source maps don't track variable usage across files

No preprocessor function mapping: darken($primary, 10%) → #2980b9 transformation is invisible

Nested to flat conversion: Nested SCSS selectors become flat CSS, but source maps only point to the parent

Generated content: Vendor prefixes, minified values, and other build-time transformations aren't annotated

Multiple sources: When a value comes from multiple rules (cascade), source maps only show the winning rule's source

Tools Used:
Chrome DevTools 122+

Vite 4.5.3 with devSourcemap: true

Built with npm run build (production source maps)

Viewed at http://localhost:4173 (preview build)

Conclusion:
Source maps are excellent for basic file/line mapping but have limitations with:

Preprocessor transformations (variables, functions, mixins)

Build-time code generation (vendor prefixes)

Complex cascade interactions

Dynamic states (pseudo-classes during interaction)

The mapping works well for direct 1:1 translations but breaks down when CSS is transformed or generated during build.